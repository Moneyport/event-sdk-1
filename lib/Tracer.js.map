{"version":3,"file":"Tracer.js","sourceRoot":"","sources":["../src/Tracer.ts"],"names":[],"mappings":";;AAAA,uDAAwH;AAExH,iCAAuE;AAEvE,MAAM,CAAC,GAAG,OAAO,CAAC,QAAQ,CAAC,CAAC;AAE5B,MAAM,WAAW,GAAG,OAAO,CAAC,aAAa,CAAC,CAAA;AAE1C;;GAEG;AAEH,MAAe,OAAO;CAOrB;AAED,MAAM,MAAM;IAEV;;;;;;OAMG;IACH,MAAM,CAAC,UAAU,CAAC,OAAe,EAAE,IAAgB,EAAE,SAAqB,EAAE,iBAA6C;QACvH,OAAO,IAAI,WAAI,CAAC,IAAI,iCAAkB,CAAC,EAAE,OAAO,EAAE,IAAI,EAAE,CAAC,EAAE,SAAS,EAAE,iBAAiB,CAAC,CAAA;IAC1F,CAAC;IAED;;;;;OAKG;IACH,MAAM,CAAC,0BAA0B,CAAC,OAAe,EAAE,WAA4B,EAAE,SAAqB;QACpG,IAAI,aAAa,GAAoB,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,WAAW,EAAE,EAAE,OAAO,EAAE,MAAM,EAAE,SAAS,EAAE,YAAY,EAAE,WAAW,CAAC,MAAM,EAAE,cAAc,EAAE,SAAS,EAAE,CAAC,CAAA;QAChK,OAAO,IAAI,WAAI,CAAC,IAAI,iCAAkB,CAAC,aAAa,CAAC,EAAE,SAAS,CAAS,CAAA;IAC3E,CAAC;IAED;;;;;OAKG;IACH,MAAM,CAAC,sBAAsB,CAAC,OAAwB,EAAE,OAA+B,EAAE,gBAAgC,EAAE;QACzH,IAAI,MAAM,GAAG,CAAC,CAAC,SAAS,CAAC,OAAO,CAAC,CAAA;QACjC,IAAI,EAAE,IAAI,EAAE,GAAG,aAAa,CAAA,CAAC,2BAA2B;QACxD,IAAI,OAAO,YAAY,2BAAY,IAAI,CAAC,CAAC,UAAU,IAAI,OAAO,CAAC,CAAC;YAAE,IAAI,GAAG,UAAU,CAAA;aAC9E,IAAI,OAAO,YAAY,iCAAkB;YAAE,OAAO,OAAO,CAAC,OAAO,CAAC,OAAO,CAAC,CAAA;QAC/E,IAAI,CAAC,IAAI;YAAE,MAAM,CAAC,MAAM,CAAC,MAAM,EAAE,EAAE,KAAK,EAAE,OAAO,EAAE,CAAC,CAAA;;YAC/C,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC,MAAM,EAAE,IAAI,CAAC,EAAE,EAAE,KAAK,EAAE,OAAO,EAAE,CAAC,CAAA;QACrD,OAAO,MAAM,CAAA;IACf,CAAC;IACD;;;;;OAKG;IAEH,MAAM,CAAC,0BAA0B,CAAC,OAAwB,EAAE,OAA+B,EAAE,OAA2B,iCAAkB,CAAC,GAAG;QAC5I,IAAI,MAAM,GAAG,CAAC,CAAC,SAAS,CAAC,OAAO,CAAC,CAAA;QACjC,MAAM,CAAC,OAAO,GAAG,oBAAa,CAAC,OAAO,EAAE,IAAI,EAAE,MAAM,CAAC,OAAO,CAAC,CAAA;QAC7D,OAAO,MAAM,CAAA;IACf,CAAC;IAED;;;;;OAKG;IACH,MAAM,CAAC,yBAAyB,CAAC,OAA+B,EAAE,iBAAiC,EAAE;QACnG,IAAI,WAAW,CAAA;QACf,IAAI,EAAE,IAAI,EAAE,GAAG,cAAc,CAAA,CAAC,2BAA2B;QACzD,IAAI,OAAO,YAAY,2BAAY,IAAI,CAAC,CAAC,UAAU,IAAI,OAAO,CAAC,IAAI,OAAO,IAAI,OAAO,CAAC,QAAQ,CAAC,EAAE;YAC/F,IAAI,GAAG,gBAAgB,CAAA;SACxB;aAAM,IAAI,OAAO,IAAI,OAAO,EAAE;YAC7B,IAAI,GAAG,OAAO,CAAA;SACf;QACD,WAAW,GAAG,IAAI,iCAAkB,CAAkB,CAAC,CAAC,GAAG,CAAC,OAAO,EAAE,IAAK,EAAE,OAAO,CAAC,CAAC,CAAA;QACrF,OAAwB,WAAW,CAAA;IACrC,CAAC;IAED,MAAM,CAAC,6BAA6B,CAAC,OAAgC,EAAE,OAA2B,iCAAkB,CAAC,GAAG;QACtH,IAAI,WAAW,CAAA;QACf,QAAQ,IAAI,EAAE;YACZ,KAAK,iCAAkB,CAAC,GAAG,CAAC,CAAC;gBAC3B,IAAI,MAAM,GAA6B,EAAE,CAAA;gBACzC,KAAK,IAAI,CAAE,GAAG,EAAE,KAAK,CAAE,IAAI,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,OAAO,CAAC,EAAE;oBAC1D,IAAI,YAAY,GAAG,GAAG,CAAC,WAAW,EAAE,CAAA;oBACpC,IAAI,YAAY,CAAC,UAAU,CAAC,OAAO,CAAC,EAAE;wBACpC,IAAI,SAAS,GAAW,GAAG,CAAC,OAAO,CAAC,OAAO,EAAE,EAAE,CAAC,CAAA;wBAChD,MAAM,CAAC,SAAS,CAAC,GAAW,KAAK,CAAA;qBAClC;iBACF;gBACD,WAAW,GAAG,IAAI,iCAAkB,CAAC,MAAM,CAAC,CAAA;gBAC5C,OAAwB,WAAW,CAAA;aACpC;YACD,KAAK,iCAAkB,CAAC,GAAG,CAAC;YAC5B,OAAO,CAAC,CAAC;gBACP,IAAI,OAAO,GAAG,WAAW,CAAC,UAAU,CAAC,OAAO,CAAC,OAAO,CAAC,WAAW,CAAC,CAAA;gBACjE,IAAI,OAAO,GAAW,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,OAAO,CAAC,KAAK,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC,CAAA;gBAC9D,WAAW,GAAG,IAAI,iCAAkB,CAAC;oBACnC,OAAO,EAAE,OAAO,CAAC,OAAO;oBACxB,MAAM,EAAE,OAAO,CAAC,EAAE;oBAClB,KAAK,EAAE,OAAO,CAAC,KAAK;oBACpB,YAAY,EAAE,OAAO,CAAC,QAAQ;oBAC9B,OAAO,EAAE,OAAO;iBACjB,CAAC,CAAA;gBACF,OAAwB,WAAW,CAAA;aACpC;SACF;IACH,CAAC;CAEF;AAGC,wBAAM","sourcesContent":["import { TraceTags, EventTraceMetadata, EventMessage, TypeSpanContext, HttpRequestOptions } from \"./model/EventMessage\";\n\nimport { Span, ContextOptions, Recorders, setHttpHeader } from \"./Span\"\n\nconst _ = require('lodash');\n\nconst TraceParent = require('traceparent')\n\n/**\n * Describes Event SDK methods from Tracer perspective\n */\n\nabstract class ATracer {\n  static createSpan: (service: string, tags?: TraceTags, recorders?: Recorders, defaultTagsSetter?: Span['defaultTagsSetter']) => Span\n  static createChildSpanFromContext: (service: string, context: TypeSpanContext, recorders?: Recorders) => {}\n  static injectContextToMessage: (context: TypeSpanContext, message: { [key: string]: any }, path?: string) => { [key: string]: any }\n  static injectContextToHttpRequest: (context: TypeSpanContext, request: { [key: string]: any }, type?: HttpRequestOptions) => { [key: string]: any }\n  static extractContextFromMessage: (message: { [key: string]: any }, path?: string) => TypeSpanContext\n  static extractContextFromHttpRequest: (request: any, type?: HttpRequestOptions) => TypeSpanContext\n}\n\nclass Tracer implements ATracer {\n\n  /**\n   * Creates new span from new trace\n   * @param service name of the service which will be asociated with the newly created span\n   * @param tags optional tags for the span\n   * @param recorders optional recorders. Defaults to defaultRecorder, which is either logger or sidecar client, based on default.json DISABLE_SIDECAR value\n   * @param defaultTagsSetter optional default tags setter method.\n   */\n  static createSpan(service: string, tags?: TraceTags, recorders?: Recorders, defaultTagsSetter?: Span['defaultTagsSetter']): Span {\n    return new Span(new EventTraceMetadata({ service, tags }), recorders, defaultTagsSetter)\n  }\n\n  /**\n   * Creates new child span from context with new service name\n   * @param service the name of the service of the new child span\n   * @param spanContext context of the previous span\n   * @param recorders optional recorders. Defaults to defaultRecorder, which is either logger or sidecar client, based on default.json DISABLE_SIDECAR value\n   */\n  static createChildSpanFromContext(service: string, spanContext: TypeSpanContext, recorders?: Recorders): Span {\n    let outputContext = <TypeSpanContext>Object.assign({}, spanContext, { service, spanId: undefined, parentSpanId: spanContext.spanId, startTimestamp: undefined })\n    return new Span(new EventTraceMetadata(outputContext), recorders) as Span\n  }\n\n  /**\n   * Injects trace context into a carrier with optional path.\n   * @param context span context to be injected\n   * @param carrier any kind of message or other object with keys of type String.\n   * @param injectOptions type and path of the carrier. Type is not implemented yet. Path is the path to the trace context.\n   */\n  static injectContextToMessage(context: TypeSpanContext, carrier: { [key: string]: any }, injectOptions: ContextOptions = {}): { [key: string]: any } {\n    let result = _.cloneDeep(carrier)\n    let { path } = injectOptions // type not implemented yet\n    if (carrier instanceof EventMessage || (('metadata' in carrier))) path = 'metadata'\n    else if (carrier instanceof EventTraceMetadata) return Promise.resolve(context)\n    if (!path) Object.assign(result, { trace: context })\n    else _.merge(_.get(result, path), { trace: context })\n    return result\n  }\n  /**\n   * Injects trace context into a http request headers.\n   * @param context span context to be injected\n   * @param request HTTP request.\n   * @param type type of the headers that will be created - 'w3c' or 'xb3'.\n   */\n\n  static injectContextToHttpRequest(context: TypeSpanContext, request: { [key: string]: any }, type: HttpRequestOptions = HttpRequestOptions.w3c): { [key: string]: any } {\n    let result = _.cloneDeep(request)\n    result.headers = setHttpHeader(context, type, result.headers)\n    return result\n  }\n\n  /**\n   * Extracts trace context from a carrier (ex: kafka message, event message, metadata, trace)\n   * with optional path for the trace context to be extracted.\n   * @param carrier any kind of message or other object with keys of type String.\n   * @param extractOptions type and path of the carrier. Type is not implemented yet. Path is the path to the trace context.\n   */\n  static extractContextFromMessage(carrier: { [key: string]: any }, extractOptions: ContextOptions = {}): TypeSpanContext {\n    let spanContext\n    let { path } = extractOptions // type not implemented yet\n    if (carrier instanceof EventMessage || (('metadata' in carrier) && 'trace' in carrier.metadata)) {\n      path = 'metadata.trace'\n    } else if ('trace' in carrier) {\n      path = 'trace'\n    }\n    spanContext = new EventTraceMetadata(<TypeSpanContext>_.get(carrier, path!, carrier))\n    return <TypeSpanContext>spanContext\n  }\n\n  static extractContextFromHttpRequest(request: { [key: string] : any }, type: HttpRequestOptions = HttpRequestOptions.w3c): TypeSpanContext {\n    let spanContext\n    switch (type) {\n      case HttpRequestOptions.xb3: {\n        let result:{ [key: string]: string } = {}\n        for (let [ key, value ] of Object.entries(request.headers)) {\n          let keyLowerCase = key.toLowerCase()\n          if (keyLowerCase.startsWith('x-b3-')) {\n            let resultKey: string = key.replace('x-b3-', '')\n            result[resultKey] = <string>value\n          }\n        }\n        spanContext = new EventTraceMetadata(result)\n        return <TypeSpanContext>spanContext\n      }\n      case HttpRequestOptions.w3c:\n      default: {\n        let context = TraceParent.fromString(request.headers.traceparent)\n        let sampled: number = context.flags ? context.flags & 0x01 : 0\n        spanContext = new EventTraceMetadata({\n          traceId: context.traceId,\n          spanId: context.id,\n          flags: context.flags,\n          parentSpanId: context.parentId,\n          sampled: sampled\n        })\n        return <TypeSpanContext>spanContext\n      }\n    }\n  }\n\n}\n\nexport {\n  Tracer\n}"]}