{"version":3,"file":"Tracer.js","sourceRoot":"","sources":["../src/Tracer.ts"],"names":[],"mappings":"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","sourcesContent":["import { TraceTags, EventTraceMetadata, EventMessage, TypeSpanContext } from \"./model/EventMessage\";\n\nimport { getNestedObject } from \"./lib/util\";\n\nimport { Span, ContextOptions, Recorders } from \"./Span\"\n\nabstract class ATracer { // TODO consider should we move those to index.js for the API\n  static createSpan: (service: string, tags?: TraceTags, recorders?: Recorders, defaultTagsSetter?: Span['defaultTagsSetter']) => Span\n  static createChildSpanFromContext: (service: string, context: TypeSpanContext, recorders?: Recorders) => {}\n  static injectContextToMessage: (context: TypeSpanContext, message: { [key: string]: any }, path?: string) => { [key: string]: any }\n  static extractContextFromMessage: (message: { [key: string]: any }, path?: string) => TypeSpanContext\n}\n\nclass Tracer implements ATracer {\n\n  static createSpan(service: string, tags?: TraceTags, recorders?: Recorders, defaultTagsSetter?: Span['defaultTagsSetter']): Span {\n    return new Span(new EventTraceMetadata({ service, tags }), recorders, defaultTagsSetter)\n  }\n\n  /**\n   * Creates new child span from context with new service name\n   * @param service the name of the service of the new child span\n   * @param spanContext context of the previous span\n   */\n  static createChildSpanFromContext(service: string, spanContext: TypeSpanContext, recorders?: Recorders): Span {\n    let outputContext = <TypeSpanContext>Object.assign({}, spanContext, { service, spanId: undefined, parentSpanId: spanContext.spanId, startTimestamp: undefined })\n    return new Span(new EventTraceMetadata(outputContext), recorders)\n  }\n\n  /**\n   * Injects trace context into a carrier with optional path.\n   * @param carrier any kind of message or other object with keys of type String.\n   * @param injectOptions type and path of the carrier. Type is not implemented yet. Path is the path to the trace context.\n   */\n  static injectContextToMessage(context: TypeSpanContext, carrier: { [key: string]: any }, injectOptions: ContextOptions = {}): Promise<{ [key: string]: any }> {\n    let result = carrier\n    let { path } = injectOptions // type not implemented yet\n    if (carrier instanceof EventMessage || (('metadata' in carrier))) path = 'metadata.trace'\n    else if (('trace' in carrier)) path = 'trace'\n    else if (carrier instanceof EventTraceMetadata) result.metadata.trace = context\n    if (path) {\n      try {\n        let pathArray: string[] = path.split('.')\n        for (let i = 0; i < pathArray.length - 1; i++) {\n          if (!result[pathArray[i]]) {\n            if (i < pathArray.length) {\n              let o: any = {}\n              o[pathArray[i + 1]] = {}\n              result[pathArray[i]] = o\n            }\n          }\n          result = result[pathArray[i]]\n        }\n      } catch (e) {\n        throw e\n      }\n    }\n    result.trace = context\n    return Promise.resolve(carrier)\n  }\n\n  /**\n   * Extracts trace context from a carrier (ex: kafka message, event message, metadata, trace)\n   * with optional path for the trace context to be extracted.\n   * @param carrier any kind of message or other object with keys of type String.\n   * @param extractOptions type and path of the carrier. Type is not implemented yet. Path is the path to the trace context.\n   */\n  static extractContextFromMessage(message: { [key: string]: any }, extractOptions: ContextOptions = {}): TypeSpanContext {\n    let spanContext\n    let { path } = extractOptions // type not implemented yet\n    if (message instanceof EventMessage || (('metadata' in message) && 'trace' in message.metadata)) {\n      path = 'metadata.trace'\n    } else if ('trace' in message) {\n      path = 'trace'\n    }\n    spanContext = new EventTraceMetadata(<TypeSpanContext>getNestedObject(message, path))\n    return <TypeSpanContext>spanContext\n  }\n}\n\nexport {\n  Tracer\n}"]}