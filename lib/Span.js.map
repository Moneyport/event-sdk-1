{"version":3,"file":"Span.js","sourceRoot":"","sources":["../src/Span.ts"],"names":[],"mappings":";;;;;;;;;;;;;AAAA,uDAoB6B;AAE7B,yCAEmB;AAEnB,qFAAkF;AAClF,oDAAuB;AAEvB,MAAM,MAAM,GAAG,OAAO,CAAC,cAAc,CAAC,CAAA;AAItC,MAAM,eAAe,GAAG,MAAM,CAAC,gBAAgB;IAC7C,CAAC,CAAC,IAAI,gCAAqB,EAAE;IAC7B,CAAC,CAAC,IAAI,iCAAsB,CAAC,IAAI,qDAAyB,CAAC,MAAM,CAAC,wBAAwB,EAAE,MAAM,CAAC,wBAAwB,CAAC,CAAC,CAAA;AA8E/H,MAAM,IAAI;IAKR;;;;;OAKG;IACH,YACE,WAA+B,EAC/B,SAAqB,EACrB,iBAAmD;QAX7C,cAAS,GAAY,KAAK,CAAA;QAgPlC;;WAEG;QACK,uBAAkB,GAAG,CAC3B,OAAsB,EACtB,IAAiC,EACjC,OAAuC,EACvC,QAA4B,iCAAkB,CAAC,OAAO,EAAE,EAAgB,EAAE;YAC1E,IAAI,QAAQ,GAAG,WAAW,CAAC,IAAI,CAAC,CAAA;YAChC,IAAI,MAAM,GAAG,OAAO,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,QAAQ,CAAC,MAAM,CAAA;YAChD,IAAI,YAAY,CAAA;YAChB,IAAI,OAAO,OAAO,KAAK,QAAQ,EAAE;gBAC/B,YAAY,GAAG,IAAI,2BAAY,CAAC;oBAC9B,OAAO,EAAE,EAAE,OAAO,EAAE,EAAE,OAAO,EAAE,EAAE;oBACjC,IAAI;iBACL,CAAC,CAAA;aACH;iBAAM,IAAI,CAAC,OAAO,OAAO,KAAK,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC,OAAO,CAAC,cAAc,CAAC,SAAS,CAAC,CAAC,IAAI,CAAC,CAAC,OAAO,CAAC,cAAc,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE;gBACvH,YAAY,GAAG,IAAI,2BAAY,CAAC;oBAC9B,OAAO,EAAE,EAAE,OAAO,EAAE,EAAE,OAAO,EAAE,EAAE;oBACjC,IAAI;iBACL,CAAC,CAAA;aACH;iBAAM;gBACL,YAAY,GAAG,IAAI,2BAAY,CAAmB,OAAO,CAAC,CAAA;aAC3D;YACD,OAAO,MAAM,CAAC,MAAM,CAAC,YAAY,EAAE;gBACjC,QAAQ,EAAE;oBACR,KAAK,EAAE,QAAQ,CAAC,oBAAoB,CAAC;wBACnC,MAAM;wBACN,KAAK;qBACN,CAAC;oBACF,KAAK,EAAmB,IAAI,CAAC,WAAW;iBACzC;aACF,CAAC,CAAA;QACJ,CAAC,CAAA;QArQC,IAAI,CAAC,WAAW,GAAG,MAAM,CAAC,MAAM,CAAC,WAAW,CAAC,CAAA;QAC7C,IAAI,CAAC,iBAAiB,GAAG,iBAAiB,CAAC,CAAC,CAAC,iBAAiB,CAAC,CAAC,CAAC,IAAI,CAAC,iBAAiB,CAAA;QACvF,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,EAAE,eAAe,EAAE,CAAA;QAC5D,IAAI,CAAC,iBAAiB,EAAE,CAAA;QACxB,OAAO,IAAI,CAAA;IACb,CAAC;IAED;;;OAGG;IAEH,iBAAiB,CAAC,OAAuB;QACvC,OAAO,IAAI,CAAA;IACb,CAAC;IAED;;OAEG;IACH,UAAU;QACR,OAAO,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,IAAI,CAAC,WAAW,EAAE,EAAE,IAAI,EAAE,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,CAAA;IACzG,CAAC;IAED;;;;SAIK;IACL,QAAQ,CAAC,OAAe,EAAE,YAAuB,IAAI,CAAC,SAAS;QAC7D,IAAI;YACF,IAAI,IAAI,CAAC,SAAS;gBAAE,MAAM,IAAI,KAAK,CAAC,yCAAyC,CAAC,CAAA;YAC9E,IAAI,iBAAiB,GAAoB,IAAI,CAAC,UAAU,EAAE,CAAA;YAC1D,OAAO,IAAI,IAAI,CAAC,IAAI,iCAAkB,CAAC,MAAM,CAAC,MAAM,CAAC,EAAE,EACrD,iBAAiB,EAAE;gBACjB,OAAO;gBACP,MAAM,EAAE,SAAS;gBACjB,cAAc,EAAE,SAAS;gBACzB,YAAY,EAAE,iBAAiB,CAAC,MAAM;aACvC,CAAC,CAAC,EAAE,SAAS,EAAE,IAAI,CAAC,iBAAiB,CAAC,CAAA;SAC1C;QAAC,OAAO,CAAC,EAAE;YACV,MAAM,CAAC,CAAC,CAAC,CAAA;SACV;IACH,CAAC;IAED;;;;OAIG;IACH,sBAAsB,CAAC,OAA+B,EAAE,gBAAgC,EAAE;QACxF,IAAI,MAAM,GAAG,gBAAC,CAAC,SAAS,CAAC,OAAO,CAAC,CAAA;QACjC,IAAI,EAAE,IAAI,EAAE,GAAG,aAAa,CAAA,CAAC,2BAA2B;QACxD,IAAI,OAAO,YAAY,2BAAY,IAAI,CAAC,CAAC,UAAU,IAAI,OAAO,CAAC,CAAC;YAAE,IAAI,GAAG,UAAU,CAAA;aAC9E,IAAI,OAAO,YAAY,iCAAkB;YAAE,OAAO,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,WAAW,CAAC,CAAA;QACxF,IAAI,CAAC,IAAI;YAAE,MAAM,CAAC,MAAM,CAAC,MAAM,EAAE,EAAE,KAAK,EAAE,IAAI,CAAC,WAAW,EAAE,CAAC,CAAA;;YACxD,gBAAC,CAAC,KAAK,CAAC,gBAAC,CAAC,GAAG,CAAC,MAAM,EAAE,IAAI,CAAC,EAAE,EAAE,KAAK,EAAE,IAAI,CAAC,WAAW,EAAE,CAAC,CAAA;QAC9D,OAAO,OAAO,CAAC,OAAO,CAAC,MAAM,CAAC,CAAA;IAChC,CAAC;IAED;;;OAGG;IACH,OAAO,CAAC,IAAe;QACrB,IAAI,UAAU,GAAoB,IAAI,iCAAkB,CAAC,IAAI,CAAC,UAAU,EAAE,CAAC,CAAA;QAC3E,KAAK,IAAI,GAAG,IAAI,IAAI,EAAE;YACpB,UAAU,CAAC,IAAK,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,CAAA;SAClC;QACD,IAAI,CAAC,WAAW,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,iCAAkB,CAAC,UAAU,CAAC,CAAC,CAAA;QACpE,OAAO,IAAI,CAAA;IACb,CAAC;IAED;;;;MAIE;IACI,MAAM,CAAC,OAAuB,EAAE,eAA+B;;YACnE,IAAI,IAAI,CAAC,WAAW,CAAC,eAAe;gBAAE,OAAO,OAAO,CAAC,MAAM,CAAC,IAAI,KAAK,CAAC,uBAAuB,CAAC,CAAC,CAAA;YAC/F,IAAI,WAAW,GAAG,IAAI,CAAC,WAAW,CAAC,eAAe,CAAC,CAAC,UAAU,EAAE,CAAA;YAChE,MAAM,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE,WAAW,CAAC,CAAA;YACtC,OAAO,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,CAAA;QAC9B,CAAC;KAAA;IAED;;;OAGG;IACK,WAAW,CAAC,eAA+B;QACjD,IAAI,UAAU,GAAqC,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,IAAI,CAAC,WAAW,CAAC,CAAA;QACtF,IAAI,eAAe,YAAY,IAAI,EAAE;YACnC,UAAU,CAAC,eAAe,GAAG,eAAe,CAAC,WAAW,EAAE,CAAA,CAAC,WAAW;SACvE;aAAM,IAAI,CAAC,eAAe,EAAE;YAC3B,UAAU,CAAC,eAAe,GAAG,CAAC,IAAI,IAAI,EAAE,CAAC,CAAC,WAAW,EAAE,CAAA,CAAC,WAAW;SACpE;aAAM;YACL,UAAU,CAAC,eAAe,GAAG,eAAe,CAAA;SAC7C;QACD,IAAI,CAAC,WAAW,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,iCAAkB,CAAC,UAAU,CAAC,CAAC,CAAA;QACpE,OAAO,IAAI,CAAA;IACb,CAAC;IAGD;;;;;;OAMG;IACW,KAAK,CAAC,OAAuB,EAAE,cAA+B,IAAI,CAAC,WAAW,EAAE,MAAyB,EAAE,KAA0B;;YACjJ,IAAI,CAAC,OAAO;gBAAE,OAAO,GAAG,IAAI,2BAAY,CAAC;oBACvC,IAAI,EAAE,OAAO;oBACb,OAAO,EAAE,WAAW;iBACrB,CAAC,CAAA;YACF,IAAI;gBACF,MAAM,IAAI,CAAC,aAAa,CAAC,OAAO,EAAE,mCAAoB,CAAC,OAAO,EAAE,EAAE,MAAM,EAAE,KAAK,CAAC,CAAA;gBAChF,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,WAAW,CAAC,eAAe,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAA;gBAChE,OAAO,IAAI,CAAA;aACZ;YAAC,OAAO,CAAC,EAAE;gBACV,MAAM,IAAI,KAAK,CAAC,6BAA6B,IAAI,CAAC,SAAS,CAAC,CAAC,EAAE,IAAI,EAAE,CAAC,CAAC,EAAE,CAAC,CAAA;aAC3E;QACH,CAAC;KAAA;IAED;;;;;OAKG;IACG,KAAK,CAAC,OAAsB,EAAE,MAAyB,EAAE,KAA0B;;YACvF,IAAI,MAAM,GAAG,MAAM,IAAI,CAAC,aAAa,CAAC,OAAO,EAAE,mCAAoB,CAAC,OAAO,EAAE,EAAE,MAAM,EAAE,KAAK,CAAC,CAAA;YAC7F,OAAO,MAAM,CAAA;QACf,CAAC;KAAA;IAED;;;;;;OAMG;IACG,IAAI,CAAC,OAAsB,EAAE,KAA0B;;YAC3D,IAAI,EAAE,MAAM,EAAE,IAAI,EAAE,GAAG,IAAI,iCAAkB,CAAC,6BAAc,CAAC,IAAI,CAAC,CAAA;YAClE,MAAM,IAAI,CAAC,aAAa,CAAC,OAAO,EAAE,IAAI,EAAE,MAAM,EAAE,KAAK,CAAC,CAAA;QACxD,CAAC;KAAA;IAED;;;;;;OAMG;IACG,KAAK,CAAC,OAAsB,EAAE,KAA0B;;YAC5D,IAAI,EAAE,MAAM,EAAE,IAAI,EAAE,GAAG,IAAI,iCAAkB,CAAC,6BAAc,CAAC,KAAK,CAAC,CAAA;YACnE,MAAM,IAAI,CAAC,aAAa,CAAC,OAAO,EAAE,IAAI,EAAE,MAAM,EAAE,KAAK,CAAC,CAAA;QACxD,CAAC;KAAA;IAED;;;;;;OAMG;IACG,OAAO,CAAC,OAAsB,EAAE,KAA0B;;YAC9D,IAAI,EAAE,MAAM,EAAE,IAAI,EAAE,GAAG,IAAI,iCAAkB,CAAC,6BAAc,CAAC,OAAO,CAAC,CAAA;YACrE,MAAM,IAAI,CAAC,aAAa,CAAC,OAAO,EAAE,IAAI,EAAE,MAAM,EAAE,KAAK,CAAC,CAAA;QACxD,CAAC;KAAA;IAED;;;;;;OAMG;IACG,WAAW,CAAC,OAAsB,EAAE,KAA0B;;YAClE,IAAI,EAAE,MAAM,EAAE,IAAI,EAAE,GAAG,IAAI,iCAAkB,CAAC,6BAAc,CAAC,WAAW,CAAC,CAAA;YACzE,MAAM,IAAI,CAAC,aAAa,CAAC,OAAO,EAAE,IAAI,EAAE,MAAM,EAAE,KAAK,CAAC,CAAA;QACxD,CAAC;KAAA;IAED;;;;;;OAMG;IACG,OAAO,CAAC,OAAsB,EAAE,KAA0B;;YAC9D,IAAI,EAAE,MAAM,EAAE,IAAI,EAAE,GAAG,IAAI,iCAAkB,CAAC,6BAAc,CAAC,OAAO,CAAC,CAAA;YACrE,MAAM,IAAI,CAAC,aAAa,CAAC,OAAO,EAAE,IAAI,EAAE,MAAM,EAAE,KAAK,CAAC,CAAA;QACxD,CAAC;KAAA;IAED;;;;;;OAMG;IACG,KAAK,CAAC,OAAsB,EAAE,KAA0B;;YAC5D,IAAI,EAAE,MAAM,EAAE,IAAI,EAAE,GAAG,IAAI,iCAAkB,CAAC,6BAAc,CAAC,KAAK,CAAC,CAAA;YACnE,MAAM,IAAI,CAAC,aAAa,CAAC,OAAO,EAAE,IAAI,EAAE,MAAM,EAAE,KAAK,CAAC,CAAA;QACxD,CAAC;KAAA;IAED;;;;;;OAMG;IAEW,aAAa,CAAC,OAAsB,EAAE,IAAiC,EAAE,MAAsC,EAAE,KAA0B;;YACvJ,IAAI,IAAI,CAAC,SAAS;gBAAE,MAAM,IAAI,KAAK,CAAC,2CAA2C,CAAC,CAAA;YAChF,IAAI,WAAW,GAAG,IAAI,CAAC,kBAAkB,CAAC,OAAO,EAAE,IAAI,EAAE,MAAM,EAAE,KAAK,CAAC,CAAA;YACvE,IAAI,SAAS,CAAA;YACb,IAAI,GAAG,GAAiB,GAAG,IAAI,UAAU,CAAA;YACzC,IAAI,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC;gBAAE,SAAS,GAAG,MAAM,IAAI,CAAC,SAAS,CAAC,GAAG,CAAE,CAAC,MAAM,CAAC,WAAW,CAAC,CAAA;;gBAC9E,SAAS,GAAG,MAAM,IAAI,CAAC,SAAS,CAAC,eAAe,CAAC,MAAM,CAAC,WAAW,CAAC,CAAA;YACzE,IAAI,gCAAiB,CAAC,QAAQ,IAAI,SAAS,CAAC,MAAM,EAAE;gBAClD,OAAO,SAAS,CAAA;aACjB;iBAAM;gBACL,MAAM,IAAI,KAAK,CAAC,wBAAwB,IAAI,IAAI,MAAM,mBAAmB,SAAS,CAAC,MAAM,EAAE,CAAC,CAAA;aAC7F;QACH,CAAC;KAAA;CAoCF;AAmCC,oBAAI;AA5BN,MAAM,WAAW,GAAG,CAAC,IAAe,EAAmB,EAAE;IACvD,QAAQ,IAAI,EAAE;QACZ,KAAK,wBAAS,CAAC,KAAK,CAAC,CAAC;YACpB,OAAO;gBACL,MAAM,EAAE,+BAAgB,CAAC,OAAO;gBAChC,oBAAoB,EAAE,4BAAa,CAAC,KAAK;aAC1C,CAAA;SACF;QACD,KAAK,wBAAS,CAAC,KAAK,CAAC,CAAC;YACpB,OAAO;gBACL,MAAM,EAAE,+BAAgB,CAAC,IAAI;gBAC7B,oBAAoB,EAAE,4BAAa,CAAC,KAAK;aAC1C,CAAA;SACF;QACD,KAAK,wBAAS,CAAC,GAAG,CAAC,CAAC;YAClB,OAAO;gBACL,MAAM,EAAE,6BAAc,CAAC,IAAI;gBAC3B,oBAAoB,EAAE,4BAAa,CAAC,GAAG;aACxC,CAAA;SACF;KACF;IACD,OAAO;QACL,MAAM,EAAE,8BAAe,CAAC,SAAS;QACjC,oBAAoB,EAAE,4BAAa,CAAC,GAAG;KACxC,CAAA;AACH,CAAC,CAAA","sourcesContent":["import {\n  NullEventAction,\n  AuditEventAction,\n  LogEventAction,\n  TraceEventAction,\n  LogResponseStatus,\n  EventType,\n  TraceTags,\n  TypeEventMessage,\n  TypeEventMetadata,\n  TypeSpanContext,\n  EventTraceMetadata,\n  EventMessage,\n  TypeEventTypeAction,\n  EventStateMetadata,\n  EventMetadata,\n  TraceEventTypeAction,\n  AuditEventTypeAction,\n  LogEventTypeAction,\n  TypeEventAction\n} from './model/EventMessage'\n\nimport {\n  IEventRecorder, DefaultLoggerRecorder, DefaultSidecarRecorder\n} from './Recorder'\n\nimport { EventLoggingServiceClient } from './transport/EventLoggingServiceClient';\nimport _ from 'lodash';\n\nconst Config = require('./lib/config')\n\ntype RecorderKeys = 'defaultRecorder' | 'logRecorder' | 'auditRecorder' | 'traceRecorder'\n\nconst defaultRecorder = Config.SIDECAR_DISABLED\n  ? new DefaultLoggerRecorder()\n  : new DefaultSidecarRecorder(new EventLoggingServiceClient(Config.EVENT_LOGGER_SERVER_HOST, Config.EVENT_LOGGER_SERVER_PORT))\n\n\ntype PartialWithDefaultRecorder<T> = {\n  [P in keyof T]?: T[P]\n} & {\n  defaultRecorder: IEventRecorder\n}\n\n/**\n * Defines Recorders type. \n * @param defaultRecorder a recorder that will be used by default by the span if the others are not present.\n * @param logRecorder a recorder that will be used to log any logging level events\n * @param auditRecorder a recorder that will be used to log audit events\n * @param traceRecorder a recorder that will be used to log trace events\n */\n\ntype Recorders = PartialWithDefaultRecorder<{\n  defaultRecorder: IEventRecorder\n  logRecorder?: IEventRecorder,\n  auditRecorder?: IEventRecorder,\n  traceRecorder?: IEventRecorder\n}>\n\n/**\n * Defines messages allowed to be sent to the Event framework\n */\ntype TypeOfMessage = { [key: string]: NonNullable<any> } | string\n\n/**\n * defines options to the injectContextToMessage and extractContextFromMessage\n * @param type the carrier type\n * @param path in the carrier where the trace context should be injected or extracted from\n */\ntype ContextOptions = {\n  type?: string,\n  path?: string\n}\n\n\n/**\n * Defines Span interface operations\n * @param {TypeSpanContext} spanContext the context of the span\n * @param {Recorders} recorders object that holds span recorders which are going to be used for different operations. defaultRecorder is obligatory\n * @param info Defines a method to log at info level a message from the span perspective\n * @param debug Defines a method to log at debug level a message from the span perspective  \n * @param verbose Defines a method to log at verbose level a message from the span perspective  \n * @param performance Defines a method to log at performance level a message from the span perspective  \n * @param warning Defines a method to log at warning level a message from the span perspective\n * @param error Defines a method to log at error level a message from the span perspective\n * @param audit Defines a method to send audit event to the auditing environment\n * @param defaultTagsSetter Defines a method to set default tags. Currently has null implementation\n * @param getContext Defines method to get the span context as JS object\n * @param finish Defines a method to finish the current span and send tracing information to the tracing environment\n * @param getChild Defines a method to get child span\n * @param setTags Defines a method to set tags to the span\n * @param injectContextToMessage Defnies a method to inject current span context into message carrier\n */\n\ninterface ISpan {\n  spanContext: TypeSpanContext\n  recorders: Recorders\n  info: (message: TypeOfMessage) => Promise<any>\n  debug: (message: TypeOfMessage) => Promise<any>\n  verbose: (message: TypeOfMessage) => Promise<any>\n  performance: (message: TypeOfMessage) => Promise<any>\n  warning: (message: TypeOfMessage) => Promise<any>\n  error: (message: TypeOfMessage) => Promise<any>\n  audit: (message: TypeOfMessage) => Promise<any>\n  // trace: (message: { [key: string]: any}) => Promise<any> // TODO need to findout is there an usecase for that \n  defaultTagsSetter: (message?: TypeOfMessage) => Span\n  getContext: () => TypeSpanContext\n  finish: (message?: TypeOfMessage, finishTimestamp?: TypeSpanContext[\"finishTimestamp\"]) => Promise<any>\n  getChild: (service: string, recorders?: Recorders) => ISpan\n  setTags: (tags: TraceTags) => Span\n  injectContextToMessage: (message: { [key: string]: any }, injectOptions: ContextOptions) => { [key: string]: any }\n}\n\nclass Span implements Partial<ISpan> {\n  spanContext: TypeSpanContext\n  recorders: Recorders\n  private _finished: boolean = false\n\n  /**\n   * Creates new span. Normally this is not used directly, but by a Tracer.createSpan method\n   * @param spanContext context of the new span. Service is obligatory. Depending on the rest provided values, the new span will be created as a parent or child span\n   * @param {Recorders} recorders different recorders to be used for different logging methods \n   * @param defaultTagsSetter the tags setter method can be passed here\n   */\n  constructor(\n    spanContext: EventTraceMetadata,\n    recorders?: Recorders,\n    defaultTagsSetter?: (message: TypeOfMessage) => any) {\n    this.spanContext = Object.freeze(spanContext)\n    this.defaultTagsSetter = defaultTagsSetter ? defaultTagsSetter : this.defaultTagsSetter\n    this.recorders = recorders ? recorders : { defaultRecorder }\n    this.defaultTagsSetter()\n    return this\n  }\n\n  /**\n   * A method to set tags by default. Not implemented yet\n   * @param message the message which tags will be extracted from\n   */\n\n  defaultTagsSetter(message?: TypeOfMessage): Span {\n    return this\n  }\n\n  /**\n   * Gets trace context from the current span\n   */\n  getContext(): TypeSpanContext {\n    return Object.assign({}, this.spanContext, { tags: JSON.parse(JSON.stringify(this.spanContext.tags)) })\n  }\n\n  /**\n     * Creates and returns new child span of the current span and changes the span service name\n     * @param service the name of the service of the new child span\n     * @param recorders the recorders which are be set to the child span. If omitted, the recorders of the parent span are used\n     */\n  getChild(service: string, recorders: Recorders = this.recorders): Span {\n    try {\n      if (this._finished) throw new Error('Finished trace cannot have a child span')\n      let inputTraceContext: TypeSpanContext = this.getContext()\n      return new Span(new EventTraceMetadata(Object.assign({},\n        inputTraceContext, {\n          service,\n          spanId: undefined,\n          startTimestamp: undefined,\n          parentSpanId: inputTraceContext.spanId\n        })), recorders, this.defaultTagsSetter)\n    } catch (e) {\n      throw (e)\n    }\n  }\n\n  /**\n   * Injects trace context into a carrier with optional path.\n   * @param carrier any kind of message or other object with keys of type String.\n   * @param injectOptions type and path of the carrier. Type is not implemented yet. Path is the path to the trace context.\n   */\n  injectContextToMessage(carrier: { [key: string]: any }, injectOptions: ContextOptions = {}): Promise<{ [key: string]: any }> {\n    let result = _.cloneDeep(carrier)\n    let { path } = injectOptions // type not implemented yet\n    if (carrier instanceof EventMessage || (('metadata' in carrier))) path = 'metadata'\n    else if (carrier instanceof EventTraceMetadata) return Promise.resolve(this.spanContext)\n    if (!path) Object.assign(result, { trace: this.spanContext })\n    else _.merge(_.get(result, path), { trace: this.spanContext })\n    return Promise.resolve(result)\n  }\n\n  /**\n   * Sets tags to the current span. If child span is created, the tags are passed on.\n   * @param tags key value pairs of tags. Tags can be changed on different child spans\n   */\n  setTags(tags: TraceTags): this {\n    let newContext: TypeSpanContext = new EventTraceMetadata(this.getContext())\n    for (let key in tags) {\n      newContext.tags![key] = tags[key]\n    }\n    this.spanContext = Object.freeze(new EventTraceMetadata(newContext))\n    return this\n  }\n\n  /**\n  * Finishes the current span and its trace and sends the data to the tracing framework.\n  * @param message optional parameter for a message to be passed to the tracing framework.\n  * @param finishTimestamp optional parameter for the finish time. If omitted, current time is used.\n  */\n  async finish(message?: TypeOfMessage, finishTimestamp?: string | Date): Promise<this> {\n    if (this.spanContext.finishTimestamp) return Promise.reject(new Error('span already finished'))\n    let spanContext = this._finishSpan(finishTimestamp).getContext()\n    await this.trace(message, spanContext)\n    return Promise.resolve(this)\n  }\n\n  /**\n   * Finishes the trace by adding finish timestamp to the current span.\n   * @param finishTimestamp optional parameter for the finish time. If omitted, current time is used.\n   */\n  private _finishSpan(finishTimestamp?: string | Date): this {\n    let newContext: TypeSpanContext = <TypeSpanContext>Object.assign({}, this.spanContext)\n    if (finishTimestamp instanceof Date) {\n      newContext.finishTimestamp = finishTimestamp.toISOString() // ISO 8601\n    } else if (!finishTimestamp) {\n      newContext.finishTimestamp = (new Date()).toISOString() // ISO 8601\n    } else {\n      newContext.finishTimestamp = finishTimestamp\n    }\n    this.spanContext = Object.freeze(new EventTraceMetadata(newContext))\n    return this\n  }\n\n\n  /**\n   * Sends trace message to the tracing framework\n   * @param message \n   * @param spanContext optional parameter. Can be used to trace previous span. If not set, the current span context is used.\n   * @param action optional parameter for action. Defaults to 'span'\n   * @param state optional parameter for state. Defaults to 'success'\n   */\n  private async trace(message?: TypeOfMessage, spanContext: TypeSpanContext = this.spanContext, action?: TraceEventAction, state?: EventStateMetadata): Promise<any> {\n    if (!message) message = new EventMessage({\n      type: 'trace',\n      content: spanContext\n    })\n    try {\n      await this.recordMessage(message, TraceEventTypeAction.getType(), action, state)\n      this._finished = this.spanContext.finishTimestamp ? true : false\n      return this\n    } catch (e) {\n      throw new Error(`Error when logging trace. ${JSON.stringify(e, null, 2)}`)\n    }\n  }\n\n  /**\n   * Sends audit type message to the event logging framework. \n   * @param message message to be recorded as audit event\n   * @param action optional parameter for action. Defaults to 'default'\n   * @param state optional parameter for state. Defaults to 'success'\n   */\n  async audit(message: TypeOfMessage, action?: AuditEventAction, state?: EventStateMetadata): Promise<any> {\n    let result = await this.recordMessage(message, AuditEventTypeAction.getType(), action, state)\n    return result\n  }\n\n  /**\n   * Logs INFO type message.\n   * @param message if message is a string, the message is added to a message property of context of an event message.\n   * If message is not following the event framework message format, the message is added as it is to the context of an event message.\n   * If message follows the event framework message format, only the metadata is updated and if message lacks an UUID it is created. \n   * @param state optional parameter for state. Defaults to 'success'\n   */\n  async info(message: TypeOfMessage, state?: EventStateMetadata): Promise<any> {\n    let { action, type } = new LogEventTypeAction(LogEventAction.info)\n    await this.recordMessage(message, type, action, state)\n  }\n\n  /**\n   * Logs DEBUG type message.\n   * @param message if message is a string, the message is added to a message property of context of an event message.\n   * If message is not following the event framework message format, the message is added as it is to the context of an event message.\n   * If message follows the event framework message format, only the metadata is updated and if message lacks an UUID it is created. \n   * @param state optional parameter for state. Defaults to 'success'\n   */\n  async debug(message: TypeOfMessage, state?: EventStateMetadata): Promise<any> {\n    let { action, type } = new LogEventTypeAction(LogEventAction.debug)\n    await this.recordMessage(message, type, action, state)\n  }\n\n  /**\n   * Logs VERBOSE type message.\n   * @param message if message is a string, the message is added to a message property of context of an event message.\n   * If message is not following the event framework message format, the message is added as it is to the context of an event message.\n   * If message follows the event framework message format, only the metadata is updated and if message lacks an UUID it is created. \n   * @param state optional parameter for state. Defaults to 'success'\n   */\n  async verbose(message: TypeOfMessage, state?: EventStateMetadata): Promise<any> {\n    let { action, type } = new LogEventTypeAction(LogEventAction.verbose)\n    await this.recordMessage(message, type, action, state)\n  }\n\n  /**\n   * Logs PERFORMANCE type message.\n   * @param message if message is a string, the message is added to a message property of context of an event message.\n   * If message is not following the event framework message format, the message is added as it is to the context of an event message.\n   * If message follows the event framework message format, only the metadata is updated and if message lacks an UUID it is created. \n   * @param state optional parameter for state. Defaults to 'success'\n   */\n  async performance(message: TypeOfMessage, state?: EventStateMetadata): Promise<any> {\n    let { action, type } = new LogEventTypeAction(LogEventAction.performance)\n    await this.recordMessage(message, type, action, state)\n  }\n\n  /**\n   * Logs WARNING type message.\n   * @param message if message is a string, the message is added to a message property of context of an event message.\n   * If message is not following the event framework message format, the message is added as it is to the context of an event message.\n   * If message follows the event framework message format, only the metadata is updated and if message lacks an UUID it is created. \n   * @param state optional parameter for state. Defaults to 'success'\n   */\n  async warning(message: TypeOfMessage, state?: EventStateMetadata): Promise<any> {\n    let { action, type } = new LogEventTypeAction(LogEventAction.warning)\n    await this.recordMessage(message, type, action, state)\n  }\n\n  /**\n   * Logs ERROR type message.\n   * @param message if message is a string, the message is added to a message property of context of an event message.\n   * If message is not following the event framework message format, the message is added as it is to the context of an event message.\n   * If message follows the event framework message format, only the metadata is updated and if message lacks an UUID it is created. \n   * @param state optional parameter for state. Defaults to 'success'\n   */\n  async error(message: TypeOfMessage, state?: EventStateMetadata): Promise<any> {\n    let { action, type } = new LogEventTypeAction(LogEventAction.error)\n    await this.recordMessage(message, type, action, state)\n  }\n\n  /**\n   * Sends Event message to recorders\n   * @param message the Event message that needs to be recorded\n   * @param type type of Event\n   * @param action optional parameter for action. The default is based on type defaults\n   * @param state optional parameter for state. Defaults to 'success'\n   */\n\n  private async recordMessage(message: TypeOfMessage, type: TypeEventTypeAction['type'], action?: TypeEventTypeAction['action'], state?: EventStateMetadata) {\n    if (this._finished) throw new Error('span finished. no further actions allowed')\n    let newEnvelope = this.createEventMessage(message, type, action, state)\n    let logResult\n    let key = <RecorderKeys>`${type}Recorder`\n    if (this.recorders[key]) logResult = await this.recorders[key]!.record(newEnvelope)\n    else logResult = await this.recorders.defaultRecorder.record(newEnvelope)\n    if (LogResponseStatus.accepted == logResult.status) {\n      return logResult\n    } else {\n      throw new Error(`Error when recording ${type}-${action} event. status: ${logResult.status}`)\n    }\n  }\n\n  /**\n   * Helper function to create event message, based on message and event types, action and state.\n   */\n  private createEventMessage = (\n    message: TypeOfMessage,\n    type: TypeEventTypeAction['type'],\n    _action?: TypeEventTypeAction['action'],\n    state: EventStateMetadata = EventStateMetadata.success()): EventMessage => {\n    let defaults = getDefaults(type)\n    let action = _action ? _action : defaults.action\n    let messageToLog\n    if (typeof message === 'string') {\n      messageToLog = new EventMessage({\n        content: { payload: { message } },\n        type\n      })\n    } else if ((typeof message === 'object') && (!(message.hasOwnProperty('content')) || !(message.hasOwnProperty('type')))) {\n      messageToLog = new EventMessage({\n        content: { payload: { message } },\n        type\n      })\n    } else {\n      messageToLog = new EventMessage(<TypeEventMessage>message)\n    }\n    return Object.assign(messageToLog, {\n      metadata: {\n        event: defaults.eventMetadataCreator({\n          action,\n          state\n        }),\n        trace: <TypeSpanContext>this.spanContext\n      }\n    })\n  }\n}\n\ninterface IDefaultActions {\n  action: TypeEventAction['action'],\n  eventMetadataCreator: (input: TypeEventMetadata) => TypeEventMetadata\n}\n\nconst getDefaults = (type: EventType): IDefaultActions => {\n  switch (type) {\n    case EventType.audit: {\n      return {\n        action: AuditEventAction.default,\n        eventMetadataCreator: EventMetadata.audit\n      }\n    }\n    case EventType.trace: {\n      return {\n        action: TraceEventAction.span,\n        eventMetadataCreator: EventMetadata.trace\n      }\n    }\n    case EventType.log: {\n      return {\n        action: LogEventAction.info,\n        eventMetadataCreator: EventMetadata.log\n      }\n    }\n  }\n  return {\n    action: NullEventAction.undefined,\n    eventMetadataCreator: EventMetadata.log\n  }\n}\n\nexport {\n  Span,\n  ContextOptions,\n  Recorders\n}"]}