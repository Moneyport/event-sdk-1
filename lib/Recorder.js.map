{"version":3,"file":"Recorder.js","sourceRoot":"","sources":["../src/Recorder.ts"],"names":[],"mappings":"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","sourcesContent":["import { EventType, LogEventAction, LogResponseStatus, TypeEventTypeAction, EventMessage } from \"./model/EventMessage\";\nimport { EventLoggingServiceClient } from \"./transport/EventLoggingServiceClient\";\n\nconst Logger = require('@mojaloop/central-services-logger')\n\n/**\n * Describes Event Recorder interface\n * @param recorder instance of EventLogingServiceClient or another recorder\n * @param preProcess preprocessing method with null implementation in the current release\n * @param postProcess postprocessing method with null implementation in the current release\n * @param record the method that records the event depending on the recorder implementation\n */\n\ninterface IEventRecorder {\n  recorder: EventLoggingServiceClient | Function\n  preProcess: (event: EventMessage) => EventMessage\n  postProcess?: (result: any) => any\n  record: (event: EventMessage, doLog?: boolean, callback?: (result: any) => void ) => Promise<any>\n}\n\nconst logWithLevel = async (message: EventMessage): Promise<any> => {\n  return new Promise((resolve, reject) => {\n    try {\n      let type: TypeEventTypeAction['type']\n      let action: TypeEventTypeAction['action']\n      if (message.metadata && message.metadata.event) {\n        type = message.metadata.event.type!\n        action = message.metadata.event.action!\n      } else {\n        type = EventType.log\n        action = LogEventAction.info\n      }\n      if (type === EventType.log && Object.values(LogEventAction).includes(action)) \n        Logger.log(action, JSON.stringify(message, null, 2))\n      else \n        Logger.log(type, JSON.stringify(message, null, 2))\n      resolve({ status: LogResponseStatus.accepted })\n    } catch(e) {\n      reject({status: LogResponseStatus.error, error: e})\n    }\n  })\n}\n\n\nclass DefaultLoggerRecorder implements IEventRecorder {\n  recorder: Function\n\n  constructor(recorder?: EventLoggingServiceClient) {\n    this.recorder = recorder ? recorder : Logger\n    return this\n  }\n\n  preProcess = (event: EventMessage): EventMessage => {\n    return event\n  }\n\n  postProcess = (result: any): any => {\n    return result\n  }\n\n  async record(event: EventMessage): Promise<any> {\n    let updatedEvent = this.preProcess(event)\n    let result = await logWithLevel(updatedEvent)\n    return this.postProcess(result)\n  }\n}\n\nclass DefaultSidecarRecorder implements IEventRecorder {\n  recorder: EventLoggingServiceClient\n\n  constructor(recorder: EventLoggingServiceClient) {\n    this.recorder = recorder\n    return this\n  }\n\n  preProcess = (event: EventMessage): EventMessage => {\n    return event\n  }\n\n  postProcess = (result: any): any => {\n    return result\n  }\n\n  async record(event: EventMessage, doLog: boolean = true): Promise<any> {\n    doLog && await logWithLevel(event)\n    let updatedEvent = this.preProcess(event)\n    let result = await this.recorder.log(updatedEvent)\n      return this.postProcess(result)\n  }\n}\n\nclass DefaultSidecarRecorderAsync implements IEventRecorder {\n  recorder: EventLoggingServiceClient\n\n  constructor(recorder: EventLoggingServiceClient) {\n    this.recorder = recorder\n    return this\n  }\n\n  preProcess = (event: EventMessage): EventMessage => {\n    return event\n  }\n\n  async record(event: EventMessage, doLog: boolean = true, callback?: (result: any) => void): Promise<any> {\n    doLog && logWithLevel(event)\n    let updatedEvent = this.preProcess(event)\n    let result = this.recorder.log(updatedEvent)\n    if (callback) {\n      return callback(result)\n    } else {\n      return result\n    }\n  }\n}\n\nexport {\n  DefaultLoggerRecorder,\n  DefaultSidecarRecorder,\n  DefaultSidecarRecorderAsync,\n  IEventRecorder\n}\n"]}