{"version":3,"file":"Recorder.js","sourceRoot":"","sources":["../src/Recorder.ts"],"names":[],"mappings":"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","sourcesContent":["import { NullEventAction, EventType, LogEventAction, LogResponseStatus, TypeEventTypeAction, EventMessage } from \"./model/EventMessage\";\nimport { EventLoggingServiceClient } from \"./transport/EventLoggingServiceClient\";\n\nconst Logger = require('@mojaloop/central-services-shared').Logger\n\ninterface IEventRecorder {\n  recorder: EventLoggingServiceClient | Function\n  preProcess: (event: EventMessage) => EventMessage\n  postProcess: (result: any) => any\n  record: (event: EventMessage) => Promise<any>\n}\n\nclass DefaultLoggerRecorder implements IEventRecorder {\n  recorder: Function = Logger\n\n  preProcess = (event: EventMessage): EventMessage => {\n    return event\n  }\n\n  postProcess = (result: any): any => {\n    return result\n  }\n\n  async record(event: EventMessage): Promise<any> {\n    let updatedEvent = this.preProcess(event)\n    let result = await this._log(updatedEvent)\n    return this.postProcess(result)\n  }\n\n  private async _log (message: EventMessage): Promise<any> {\n    return new Promise((resolve, reject) => {\n      try {\n        let type: TypeEventTypeAction['type']\n        let action: TypeEventTypeAction['action']\n        if (message.metadata && message.metadata.event) {\n          type = message.metadata.event.type || EventType.undefined\n          action = message.metadata.event.action || NullEventAction.undefined\n        } else {\n          type = EventType.log\n          action = LogEventAction.info\n        }\n        let result\n        if (type === EventType.log && Object.values(LogEventAction).includes(action)) \n          result = Logger.log(action, JSON.stringify(message, null, 2))\n        else if (type === EventType.audit || type === EventType.trace) \n          result = Logger.log(type, JSON.stringify(message, null, 2))\n        else result = Logger.error('The event message is not following the format')  \n          let status = !result.exitOnError ? LogResponseStatus.accepted : LogResponseStatus.error\n        resolve({ status })\n      } catch(e) {\n        reject(e)\n      }\n    })\n  }\n}\n\nclass DefaultSidecarRecorder implements IEventRecorder {\n  recorder: EventLoggingServiceClient\n\n  constructor(recorder: EventLoggingServiceClient) {\n    this.recorder = recorder\n    return this\n  }\n\n  preProcess = (event: EventMessage): EventMessage => {\n    return event\n  }\n\n  postProcess = (result: any): any => {\n    return result\n  }\n\n  async record(event: EventMessage): Promise<any> {\n    let updatedEvent = this.preProcess(event)\n    let result = await this.recorder.log(updatedEvent)\n      return this.postProcess(result)\n  }\n}\n\nexport {\n  DefaultLoggerRecorder,\n  DefaultSidecarRecorder,\n  IEventRecorder\n}\n"]}