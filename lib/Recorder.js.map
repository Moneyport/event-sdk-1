{"version":3,"file":"Recorder.js","sourceRoot":"","sources":["../src/Recorder.ts"],"names":[],"mappings":";;;;;;;;;;AAAA,uDAAwI;AAGxI,MAAM,MAAM,GAAG,OAAO,CAAC,mCAAmC,CAAC,CAAC,MAAM,CAAA;AASlE,MAAM,qBAAqB;IAA3B;QACE,aAAQ,GAAa,MAAM,CAAA;QAE3B,eAAU,GAAG,CAAC,KAAmB,EAAgB,EAAE;YACjD,OAAO,KAAK,CAAA;QACd,CAAC,CAAA;QAED,gBAAW,GAAG,CAAC,MAAW,EAAO,EAAE;YACjC,OAAO,MAAM,CAAA;QACf,CAAC,CAAA;IA8BH,CAAC;IA5BO,MAAM,CAAC,KAAmB;;YAC9B,IAAI,YAAY,GAAG,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,CAAA;YACzC,IAAI,MAAM,GAAG,MAAM,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,CAAA;YAC1C,OAAO,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,CAAA;QACjC,CAAC;KAAA;IAEa,IAAI,CAAE,OAAqB;;YACvC,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;gBACrC,IAAI;oBACF,IAAI,IAAiC,CAAA;oBACrC,IAAI,MAAqC,CAAA;oBACzC,IAAI,OAAO,CAAC,QAAQ,IAAI,OAAO,CAAC,QAAQ,CAAC,KAAK,EAAE;wBAC9C,IAAI,GAAG,OAAO,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAK,CAAA;wBACnC,MAAM,GAAG,OAAO,CAAC,QAAQ,CAAC,KAAK,CAAC,MAAO,CAAA;qBACxC;yBAAM;wBACL,IAAI,GAAG,wBAAS,CAAC,GAAG,CAAA;wBACpB,MAAM,GAAG,6BAAc,CAAC,IAAI,CAAA;qBAC7B;oBACD,IAAI,IAAI,KAAK,wBAAS,CAAC,GAAG,IAAI,MAAM,CAAC,MAAM,CAAC,6BAAc,CAAC,CAAC,QAAQ,CAAC,MAAM,CAAC;wBAC1E,MAAM,CAAC,GAAG,CAAC,MAAM,EAAE,IAAI,CAAC,SAAS,CAAC,OAAO,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC,CAAA;;wBAEpD,MAAM,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,SAAS,CAAC,OAAO,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC,CAAA;oBACpD,OAAO,CAAC,EAAE,MAAM,EAAE,gCAAiB,CAAC,QAAQ,EAAE,CAAC,CAAA;iBAChD;gBAAC,OAAM,CAAC,EAAE;oBACT,MAAM,CAAC,EAAC,MAAM,EAAE,gCAAiB,CAAC,KAAK,EAAE,KAAK,EAAE,CAAC,EAAC,CAAC,CAAA;iBACpD;YACH,CAAC,CAAC,CAAA;QACJ,CAAC;KAAA;CACF;AA0BC,sDAAqB;AAxBvB,MAAM,sBAAsB;IAG1B,YAAY,QAAmC;QAK/C,eAAU,GAAG,CAAC,KAAmB,EAAgB,EAAE;YACjD,OAAO,KAAK,CAAA;QACd,CAAC,CAAA;QAED,gBAAW,GAAG,CAAC,MAAW,EAAO,EAAE;YACjC,OAAO,MAAM,CAAA;QACf,CAAC,CAAA;QAVC,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAA;QACxB,OAAO,IAAI,CAAA;IACb,CAAC;IAUK,MAAM,CAAC,KAAmB;;YAC9B,IAAI,YAAY,GAAG,IAAI,CAAC,UAAU,CAAC,KAAK,CAAC,CAAA;YACzC,IAAI,MAAM,GAAG,MAAM,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,YAAY,CAAC,CAAA;YAChD,OAAO,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,CAAA;QACnC,CAAC;KAAA;CACF;AAIC,wDAAsB","sourcesContent":["import { NullEventAction, EventType, LogEventAction, LogResponseStatus, TypeEventTypeAction, EventMessage } from \"./model/EventMessage\";\nimport { EventLoggingServiceClient } from \"./transport/EventLoggingServiceClient\";\n\nconst Logger = require('@mojaloop/central-services-shared').Logger\n\ninterface IEventRecorder {\n  recorder: EventLoggingServiceClient | Function\n  preProcess: (event: EventMessage) => EventMessage\n  postProcess: (result: any) => any\n  record: (event: EventMessage) => Promise<any>\n}\n\nclass DefaultLoggerRecorder implements IEventRecorder {\n  recorder: Function = Logger\n\n  preProcess = (event: EventMessage): EventMessage => {\n    return event\n  }\n\n  postProcess = (result: any): any => {\n    return result\n  }\n\n  async record(event: EventMessage): Promise<any> {\n    let updatedEvent = this.preProcess(event)\n    let result = await this._log(updatedEvent)\n    return this.postProcess(result)\n  }\n\n  private async _log (message: EventMessage): Promise<any> {\n    return new Promise((resolve, reject) => {\n      try {\n        let type: TypeEventTypeAction['type']\n        let action: TypeEventTypeAction['action']\n        if (message.metadata && message.metadata.event) {\n          type = message.metadata.event.type!\n          action = message.metadata.event.action!\n        } else {\n          type = EventType.log\n          action = LogEventAction.info\n        }\n        if (type === EventType.log && Object.values(LogEventAction).includes(action)) \n          Logger.log(action, JSON.stringify(message, null, 2))\n        else \n          Logger.log(type, JSON.stringify(message, null, 2))\n        resolve({ status: LogResponseStatus.accepted })\n      } catch(e) {\n        reject({status: LogResponseStatus.error, error: e})\n      }\n    })\n  }\n}\n\nclass DefaultSidecarRecorder implements IEventRecorder {\n  recorder: EventLoggingServiceClient\n\n  constructor(recorder: EventLoggingServiceClient) {\n    this.recorder = recorder\n    return this\n  }\n\n  preProcess = (event: EventMessage): EventMessage => {\n    return event\n  }\n\n  postProcess = (result: any): any => {\n    return result\n  }\n\n  async record(event: EventMessage): Promise<any> {\n    let updatedEvent = this.preProcess(event)\n    let result = await this.recorder.log(updatedEvent)\n      return this.postProcess(result)\n  }\n}\n\nexport {\n  DefaultLoggerRecorder,\n  DefaultSidecarRecorder,\n  IEventRecorder\n}\n"]}